var BABYLON;!function(e){var r=function(e){function r(r,t,n,a,i){e.call(this,r,t,"starfieldProceduralTexture",n,a,i),this._time=1,this._alpha=.5,this._beta=.8,this._zoom=.8,this.updateShaderUniforms()}return __extends(r,e),r.prototype.updateShaderUniforms=function(){this.setFloat("time",this._time),this.setFloat("alpha",this._alpha),this.setFloat("beta",this._beta),this.setFloat("zoom",this._zoom)},Object.defineProperty(r.prototype,"time",{get:function(){return this._time},set:function(e){this._time=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"alpha",{get:function(){return this._alpha},set:function(e){this._alpha=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"beta",{get:function(){return this._beta},set:function(e){this._beta=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"zoom",{get:function(){return this._zoom},set:function(e){this._zoom=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),r}(e.ProceduralTexture);e.StarfieldProceduralTexture=r}(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.starfieldProceduralTexturePixelShader="precision highp float;\r\n\r\n#define iterations 15\r\n#define formuparam 0.53\r\n\r\n#define volsteps 20\r\n#define stepsize 0.1\r\n\r\n#define tile 0.850\r\n\r\n#define brightness 0.0015\r\n#define darkmatter 0.400\r\n#define distfading 0.730\r\n#define saturation 0.850\r\n\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nuniform float time;\r\nuniform float alpha;\r\nuniform float beta;\r\nuniform float zoom;\r\n\r\nvoid main()\r\n{\r\n	vec3 dir = vec3(vUV * zoom, 1.);\r\n\r\n	float localTime = time * 0.0001;\r\n\r\n	// Rotation\r\n	mat2 rot1 = mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha));\r\n	mat2 rot2 = mat2(cos(beta), sin(beta), -sin(beta), cos(beta));\r\n	dir.xz *= rot1;\r\n	dir.xy *= rot2;\r\n	vec3 from = vec3(1., .5, 0.5);\r\n	from += vec3(localTime*2., localTime, -2.);\r\n	from.xz *= rot1;\r\n	from.xy *= rot2;\r\n\r\n	//volumetric rendering\r\n	float s = 0.1, fade = 1.;\r\n	vec3 v = vec3(0.);\r\n	for (int r = 0; r < volsteps; r++) {\r\n		vec3 p = from + s*dir*.5;\r\n		p = abs(vec3(tile) - mod(p, vec3(tile*2.))); // tiling fold\r\n		float pa, a = pa = 0.;\r\n		for (int i = 0; i < iterations; i++) {\r\n			p = abs(p) / dot(p, p) - formuparam; // the magic formula\r\n			a += abs(length(p) - pa); // absolute sum of average change\r\n			pa = length(p);\r\n		}\r\n		float dm = max(0., darkmatter - a*a*.001); //dark matter\r\n		a *= a*a; // add contrast\r\n		if (r > 6) fade *= 1. - dm; // dark matter, don't render near\r\n								  //v+=vec3(dm,dm*.5,0.);\r\n		v += fade;\r\n		v += vec3(s, s*s, s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n		fade *= distfading; // distance fading\r\n		s += stepsize;\r\n	}\r\n	v = mix(vec3(length(v)), v, saturation); //color adjust\r\n	gl_FragColor = vec4(v*.01, 1.);\r\n}";